/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ACLReadObservation struct {
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type ACLReadParameters struct {

	// +kubebuilder:validation:Optional
	ProjectAccess *bool `json:"projectAccess,omitempty" tf:"project_access,omitempty"`

	// +kubebuilder:validation:Optional
	Users []*string `json:"users,omitempty" tf:"users,omitempty"`
}

type SecretV1ACLObservation struct {
}

type SecretV1ACLParameters struct {

	// +kubebuilder:validation:Optional
	Read []ACLReadParameters `json:"read,omitempty" tf:"read,omitempty"`
}

type SecretV1Observation struct {
	AllMetadata map[string]*string `json:"allMetadata,omitempty" tf:"all_metadata,omitempty"`

	ContentTypes map[string]*string `json:"contentTypes,omitempty" tf:"content_types,omitempty"`

	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	CreatorID *string `json:"creatorId,omitempty" tf:"creator_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	SecretRef *string `json:"secretRef,omitempty" tf:"secret_ref,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type SecretV1Parameters struct {

	// +kubebuilder:validation:Optional
	ACL []SecretV1ACLParameters `json:"acl,omitempty" tf:"acl,omitempty"`

	// +kubebuilder:validation:Optional
	Algorithm *string `json:"algorithm,omitempty" tf:"algorithm,omitempty"`

	// +kubebuilder:validation:Optional
	BitLength *float64 `json:"bitLength,omitempty" tf:"bit_length,omitempty"`

	// +kubebuilder:validation:Optional
	Expiration *string `json:"expiration,omitempty" tf:"expiration,omitempty"`

	// +kubebuilder:validation:Optional
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	PayloadContentEncoding *string `json:"payloadContentEncoding,omitempty" tf:"payload_content_encoding,omitempty"`

	// +kubebuilder:validation:Optional
	PayloadContentType *string `json:"payloadContentType,omitempty" tf:"payload_content_type,omitempty"`

	// +kubebuilder:validation:Optional
	PayloadSecretRef *v1.SecretKeySelector `json:"payloadSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	SecretType *string `json:"secretType,omitempty" tf:"secret_type,omitempty"`
}

// SecretV1Spec defines the desired state of SecretV1
type SecretV1Spec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SecretV1Parameters `json:"forProvider"`
}

// SecretV1Status defines the observed state of SecretV1.
type SecretV1Status struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SecretV1Observation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// SecretV1 is the Schema for the SecretV1s API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,openstackjet}
type SecretV1 struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SecretV1Spec   `json:"spec"`
	Status            SecretV1Status `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SecretV1List contains a list of SecretV1s
type SecretV1List struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SecretV1 `json:"items"`
}

// Repository type metadata.
var (
	SecretV1_Kind             = "SecretV1"
	SecretV1_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SecretV1_Kind}.String()
	SecretV1_KindAPIVersion   = SecretV1_Kind + "." + CRDGroupVersion.String()
	SecretV1_GroupVersionKind = CRDGroupVersion.WithKind(SecretV1_Kind)
)

func init() {
	SchemeBuilder.Register(&SecretV1{}, &SecretV1List{})
}
